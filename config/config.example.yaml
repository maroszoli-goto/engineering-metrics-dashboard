github:
  token: "your_github_personal_access_token_here"

  # Option 1: Track specific repositories
  repositories:
    - owner: "your-org"
      repo: "your-repo"
    - owner: "your-org"
      repo: "another-repo"

  # Option 2: Track all repos in an organization (comment out repositories above if using this)
  # organization: "your-org-name"

  # Filter metrics to specific team members (optional)
  # If set, only PRs, commits, and reviews from these users will be included
  team_member_usernames:
    - "github-username1"
    - "github-username2"

  # Date range for metrics collection
  days_back: 90

jira:
  # Multi-Environment Support
  # ------------------------
  # NEW: You can configure multiple Jira environments (prod, uat, staging, etc.)
  # Each environment has separate credentials, filter IDs, and time offsets.
  #
  # IMPORTANT: time_offset_days applies to BOTH GitHub and Jira collectors
  # to ensure data alignment for DORA metrics calculation.
  #
  # LEGACY FORMAT (single environment):
  # If you don't need multi-environment support, use flat config:
  #   server: "https://jira.yourcompany.com"
  #   username: "username"
  #   api_token: "token"
  #   project_keys: ["PROJ"]
  #
  # NEW FORMAT (multi-environment):
  default_environment: "prod"  # Used when --env flag not specified

  environments:
    prod:
      server: "https://jira.yourcompany.com"
      username: "your-username"  # NOT email for self-hosted Jira
      api_token: "your_bearer_token"
      project_keys:
        - "PROJ"
        - "TEAM"
      time_offset_days: 0  # Production is current (no offset)
                          # NOTE: Applies to BOTH GitHub and Jira collectors

      # Pagination settings for large datasets
      pagination:
        enabled: true
        batch_size: 500
        huge_dataset_threshold: 5000
        fetch_changelog_for_large: false
        max_retries: 3
        retry_delay_seconds: 5

    uat:
      server: "https://jira-uat.yourcompany.com"
      username: "your-username"
      api_token: "uat_bearer_token"
      project_keys:
        - "PROJ"
        - "TEAM"
      time_offset_days: 180  # UAT is 6 months (180 days) behind prod
                            # NOTE: Applies to BOTH GitHub and Jira collectors
                            # GitHub: Queries current API, filters by dates from 180 days ago
                            # Jira: Queries UAT database (snapshot from 180 days ago)

      pagination:
        enabled: true
        batch_size: 500
        huge_dataset_threshold: 0  # Disable changelog for UAT (faster, fewer timeouts)
        fetch_changelog_for_large: false
        max_retries: 5
        retry_delay_seconds: 5

# Team configurations
#
# Member Format Options:
# ----------------------
# Option 1 (Simple format): List of username strings
#   - Just GitHub usernames as strings
#   - Members are matched by index with Jira members
#   - Shown below for Team Alpha
#
# Option 2 (NEW - With display names): List of dicts with username and name
#   - Supports displaying full names instead of usernames in UI
#   - Format: - username: "github-username"
#             name: "Full Name"
#   - Example shown in comments below
#
# Option 3 (Explicit mapping): Member dicts with github/jira keys
#   - More explicit, safer when GitHub and Jira usernames differ
#   - Enables per-person Jira metrics on person dashboard
#
# NEW DISPLAY NAME FORMAT (uncomment to use):
# github:
#   members:
#     - username: "jsmith"
#       name: "John Smith"
#     - username: "alee"
#       name: "Alice Lee"
#
teams:
  - name: "Backend"
    display_name: "Backend Team"
    members:
        - name: "John Smith"
          github: "jsmith"
          jira: "john.smith"
        - name: "Alice Lee"
          github: "alee"
          jira: "alice.lee"
        - name: "Bob Chen"
          github: "bchen"
          jira: "bob.chen"
        - name: "Maria Garcia"
          github: "mgarcia"
          jira: "maria.garcia"
        - name: "David Kim"
          github: "dkim"
          jira: "david.kim"
    github:
      team_slug: "backend-team"
    jira:
      # Filter IDs - run list_jira_filters.py to discover these
      # IMPORTANT: Filters should NOT contain ORDER BY or hardcoded time constraints
      # - Remove: created >= -12w, resolved >= -12w, resolutiondate >= -12w
      # - Let Python code handle date filtering dynamically based on --date-range
      #
      # NEW: Environment-specific filter IDs
      # Each environment (prod, uat) needs separate filter IDs
      filters:
        prod:
          bugs: 12345
          bugs_created: 12346
          bugs_resolved: 12347
          completed: 12348
          flagged_blocked: 12349
          scope: 12350
          wip: 12351
          incidents: 12352  # Production incidents for DORA CFR/MTTR
        uat:
          bugs: 22345
          bugs_created: 22346
          bugs_resolved: 22347
          completed: 22348
          flagged_blocked: 22349
          scope: 22350
          wip: 22351
          incidents: 22352
      #
      # LEGACY FORMAT (single environment):
      # If not using multi-environment, use flat filter IDs:
      #   bugs: 12345
      #   bugs_created: 12346
      #   ...etc

  - name: "Frontend"
    display_name: "Frontend Team"
    # New format: Explicit GitHub/Jira mapping (recommended)
    members:
      - name: "Sarah Johnson"
        github: "sjohnson"
        jira: "sarah.johnson"
      - name: "Tom Wilson"
        github: "twilson"
        jira: "tom.wilson"
      - name: "Emma Davis"
        github: "edavis"
        jira: "emma.davis"
      - name: "Michael Brown"
        github: "mbrown"
        jira: "michael.brown"
      - name: "Lisa Martinez"
        github: "lmartinez"
        jira: "lisa.martinez"
    github:
      team_slug: "frontend-team"
    jira:
      # Filter IDs - run list_jira_filters.py to discover these
      filters:
        prod:
          bugs: 13345
          bugs_created: 13346
          bugs_resolved: 13347
          completed: 13348
          flagged_blocked: 13349
          scope: 13350
          wip: 13351
          incidents: 13352  # Production incidents for DORA CFR/MTTR metrics
        uat:
          bugs: 23345
          bugs_created: 23346
          bugs_resolved: 23347
          completed: 23348
          flagged_blocked: 23349
          scope: 23350
          wip: 23351
          incidents: 23352

# Time period configurations
time_periods:
  last_n_days: [7, 14, 30, 60, 90]
  quarters_enabled: true
  custom_range_enabled: true
  max_days_back: 365

# Activity threshold configurations
activity_thresholds:
  minimum_values:
    prs_per_month: 5
    reviews_per_month: 10
    commits_per_month: 20
  trend_decline_threshold_percent: 20  # Flag if declined >20%
  below_average_threshold_percent: 70  # Flag if <70% of team average

# DORA Metrics configurations
dora_metrics:
  max_lead_time_days: 180  # Filter out lead times > 180 days (likely data errors)
  cfr_correlation_window_hours: 24  # Hours after deployment to correlate incidents

# Dashboard settings
dashboard:
  port: 5001
  debug: false  # IMPORTANT: Always false in production (disables Flask debug mode)
                # Debug mode exposes stack traces and enables auto-reloader
  cache_duration_minutes: 60  # How long to cache metrics before auto-refresh
  jira_timeout_seconds: 120   # Timeout for Jira API requests (increase if seeing 504 errors)
  enable_hsts: false  # HTTPS Strict Transport Security (HSTS)
                     # Set to true ONLY after HTTPS is configured and working
                     # Forces browsers to use HTTPS for all requests (max-age=31536000)
                     # See: docs/PRODUCTION_DEPLOYMENT.md for HTTPS setup

  # Enhanced Cache Configuration (optional)
  # Two-tier caching (memory + disk) for faster response times
  cache:
    max_memory_mb: 500          # Maximum memory cache size in MB (default: 500)
    enable_memory_cache: true   # Enable in-memory caching layer (default: true)
    warm_on_startup: true       # Pre-load common ranges on startup (default: true)
    warm_keys:                  # Keys to pre-load (default: 90d, 30d, 180d for prod)
      - "90d_prod"
      - "30d_prod"
      - "180d_prod"

  # =============================================================================
  # SECURITY: Authentication (RECOMMENDED for production)
  # =============================================================================
  # Protects dashboard with HTTP Basic Authentication (PBKDF2-SHA256 hashing)
  # All 21+ routes require authentication when enabled
  #
  # Setup:
  #   1. Generate password hash: python scripts/generate_password_hash.py
  #   2. Copy hash to password_hash field below
  #   3. Uncomment user entries and set enabled: true
  #   4. Restart dashboard
  #
  # Features:
  #   - Multiple user support (admins, viewers, etc.)
  #   - 600,000 PBKDF2 iterations (strong hashing)
  #   - Authentication bypass prevention (SQL injection tested)
  #   - Zero overhead when disabled (backward compatible)
  #
  # Testing:
  #   curl -v http://localhost:5001/  # Should return 401
  #   curl -v -u admin:password http://localhost:5001/  # Should return 200
  #
  # See: docs/AUTHENTICATION.md for complete guide
  auth:
    enabled: false  # PRODUCTION: Change to true and configure users below
    users:
      # - username: admin
      #   password_hash: pbkdf2:sha256:600000$...  # Generate with scripts/generate_password_hash.py
      # - username: viewer
      #   password_hash: pbkdf2:sha256:600000$...  # Read-only access (same as admin currently)

  # =============================================================================
  # SECURITY: Rate Limiting (RECOMMENDED for production)
  # =============================================================================
  # Prevents brute force attacks and API abuse with Flask-Limiter
  # Tracks requests per-user (authenticated) or per-IP (anonymous)
  #
  # Automatically applied limits:
  #   - General browsing: 200/hour (default, all routes)
  #   - Authentication endpoints (/api/metrics, /api/refresh): 10/minute (brute force protection)
  #   - Data collection (/api/collect): 5/hour (expensive operation)
  #   - Export operations (/api/export/*): 20/hour (prevent abuse)
  #   - Cache operations (/api/cache/*): 30-60/hour (resource protection)
  #
  # Storage Options:
  #   - memory:// (default) - In-memory storage, single process only
  #   - redis://localhost:6379 - Redis storage, production recommended for multiple workers
  #
  # Testing:
  #   # Make 11 requests to /api/metrics in 1 minute - should get 429 on 11th
  #   for i in {1..11}; do curl -u admin:pass http://localhost:5001/api/metrics; done
  #
  # See: docs/SECURITY.md for rate limit configuration
  rate_limiting:
    enabled: true  # Recommended for production
    default_limit: "200 per hour"  # Adjust based on expected traffic
    storage_uri: "memory://"  # PRODUCTION: Use redis://localhost:6379 for multiple workers

# Parallel Data Collection (optional)
# Speeds up data collection by running teams, persons, repos, and filters concurrently.
# This reduces collection time from ~18 hours to ~4 hours for 12 date ranges (4-5x speedup).
#
# Defaults (if not specified):
#   enabled: true
#   person_workers: 8
#   team_workers: 3
#   repo_workers: 5
#   filter_workers: 4
#
# Set enabled: false to use sequential collection if issues arise.
#
# parallel_collection:
#   enabled: true           # Master switch for parallel collection
#   person_workers: 8       # Number of persons to collect in parallel
#   team_workers: 3         # Number of teams to collect in parallel
#   repo_workers: 5         # Number of repos per team to collect in parallel
#   filter_workers: 4       # Number of Jira filters per team to collect in parallel

# Performance Score Weights (optional)
# These weights determine how different metrics contribute to performance scores
# in team and member comparisons. All weights must sum to 1.0 (100%).
#
# If not specified, system uses these defaults:
#   GitHub metrics (55%): PRs, Reviews, Commits, Cycle Time, Merge Rate
#   DORA metrics (30%): Deployment Frequency, Lead Time, CFR, MTTR
#   Jira metrics (15%): Jira Completed
#
# You can customize these via the Settings page in the dashboard
# (http://localhost:5001/settings) without editing this file.
#
# performance_weights:
#   # GitHub metrics
#   prs: 0.15                    # Pull requests created (higher is better)
#   reviews: 0.15                # Code reviews given (higher is better)
#   commits: 0.10                # Commits made (higher is better)
#   cycle_time: 0.10             # PR cycle time (lower is better)
#   merge_rate: 0.05             # PR merge success rate (higher is better)
#   jira_completed: 0.15         # Jira issues completed (higher is better)
#   # DORA metrics (requires releases and incident tracking)
#   deployment_frequency: 0.10   # Deployments per week (higher is better)
#   lead_time: 0.10              # Lead time for changes (lower is better)
#   change_failure_rate: 0.05    # % deployments causing incidents (lower is better)
#   mttr: 0.05                   # Mean time to recover from incidents (lower is better)

# =============================================================================
# SECURITY CONFIGURATION SUMMARY
# =============================================================================
# The dashboard implements 7 layers of security for production deployments:
#
# 1. âœ… Authentication (dashboard.auth)
#    - HTTP Basic Auth with PBKDF2-SHA256 hashing
#    - Configure above in dashboard.auth section
#
# 2. âœ… Rate Limiting (dashboard.rate_limiting)
#    - Prevents brute force attacks and API abuse
#    - Configure above in dashboard.rate_limiting section
#
# 3. âœ… Security Headers (automatic, always enabled)
#    - X-Content-Type-Options: nosniff (prevents MIME sniffing)
#    - X-Frame-Options: SAMEORIGIN (prevents clickjacking)
#    - Content-Security-Policy (prevents XSS attacks)
#    - Referrer-Policy: strict-origin-when-cross-origin
#    - Permissions-Policy (disables unnecessary browser features)
#    - Strict-Transport-Security (HSTS, enable after HTTPS)
#
# 4. âœ… Input Validation (automatic, always enabled)
#    - Protects against: SQL injection, XSS, path traversal, command injection
#    - Validates all route parameters (team names, usernames, date ranges)
#    - Returns 400 Bad Request for invalid input
#
# 5. âœ… HTTPS/TLS (manual setup required)
#    - See: docs/PRODUCTION_DEPLOYMENT.md for complete guide
#    - Includes: Nginx reverse proxy + Let's Encrypt SSL certificates
#    - Enable HSTS after HTTPS: dashboard.enable_hsts: true
#
# 6. âœ… Security Monitoring (manual setup required)
#    - Script: scripts/monitor_security_logs.sh
#    - Monitors: Failed logins, rate limits, attack patterns
#    - Setup: ./scripts/monitor_security_logs.sh admin@company.com
#    - Schedule: 0 * * * * /path/to/monitor_security_logs.sh admin@email.com
#
# 7. âœ… Dependency Scanning (manual, run periodically)
#    - Install: pip install -r requirements-dev.txt
#    - Run: safety check
#    - Result (2026-01-28): 0 vulnerabilities found
#
# =============================================================================
# PRODUCTION DEPLOYMENT CHECKLIST
# =============================================================================
# Before deploying to production, complete these steps:
#
# [ ] Configuration
#     [ ] Set dashboard.debug: false
#     [ ] Generate password hashes: python scripts/generate_password_hash.py
#     [ ] Enable authentication: dashboard.auth.enabled: true
#     [ ] Configure users in dashboard.auth.users
#     [ ] Enable rate limiting: dashboard.rate_limiting.enabled: true
#     [ ] Set file permissions: chmod 600 config/config.yaml
#
# [ ] HTTPS Setup (see docs/PRODUCTION_DEPLOYMENT.md)
#     [ ] Configure Nginx reverse proxy
#     [ ] Obtain SSL certificate (Let's Encrypt recommended)
#     [ ] Test HTTPS connection works
#     [ ] Enable HSTS: dashboard.enable_hsts: true
#     [ ] Test HTTPâ†’HTTPS redirect
#
# [ ] Security Monitoring
#     [ ] Set up log monitoring: scripts/monitor_security_logs.sh
#     [ ] Configure email alerts
#     [ ] Schedule via cron (hourly recommended)
#     [ ] Test alerts are working
#
# [ ] Testing
#     [ ] Run security tests: pytest tests/security/ (67 tests)
#     [ ] Run full test suite: pytest tests/ (1,174 tests)
#     [ ] Manual security testing (try SQL injection, path traversal)
#     [ ] Dependency scan: safety check
#
# [ ] Documentation
#     [ ] Document deployment architecture
#     [ ] Document security contacts
#     [ ] Document incident response plan
#     [ ] Document backup procedures
#
# =============================================================================
# SECURITY DOCUMENTATION
# =============================================================================
# Complete security guides available in docs/ directory:
#
# - docs/SECURITY_IMPLEMENTATION_REPORT.md - Complete implementation report
# - docs/SECURITY.md - Production security best practices
# - docs/AUTHENTICATION.md - Authentication setup guide
# - docs/PRODUCTION_DEPLOYMENT.md - HTTPS and reverse proxy setup (700+ lines)
#
# Scripts:
# - scripts/generate_password_hash.py - Generate password hashes
# - scripts/monitor_security_logs.sh - Security log monitoring
#
# Testing:
# - tests/security/ - 67 security tests (100% passing)
#   - test_authentication.py - 18 authentication tests
#   - test_input_validation.py - 36 input validation tests
#
# Security Status: ðŸŸ¢ PRODUCTION READY
# Test Coverage: 79.17% (1,174 tests passing)
# Last Security Audit: 2026-01-28
# =============================================================================
